# 毕业项目

[TOC]

## 要求

对当下自己项目中的业务，进行一个微服务改造，需要考虑如下技术点：

1）微服务架构（BFF、Service、Admin、Job、Task 分模块）
2）API 设计（包括 API 定义、错误码规范、Error 的使用）
3）gRPC 的使用
4）Go 项目工程化（项目结构、DI、代码分层、ORM 框架）
5）并发的使用（errgroup 的并行链路请求)
6）微服务中间件的使用（ELK、Opentracing、Prometheus、Kafka）
7）缓存的使用优化（一致性处理、Pipeline 优化)



## 现有项目介绍

### 项目概要说明

该项目用于某行业的远端网关设备的集中管理,传感器数据采集,摄像头推流及集中控制.

规模: 需管理数百台网关设备

网络架构为星型架构,各网关设备通过4G上网卡连接到数据中心服务器.

服务器侧,主业务Service用于
- 网关设备的管理(增删改查)
- 网关设备的配置设置及下发(各外设配置,传感器采集上报方式等)
- 网关设备的在线状态查看(各关键board参数)
- 暴露HTTP(S) API接口给第三方,用于摄像头设备的控制(旋转,焦距调整,推流开始及结束,截图等)


特点:
- 视频监控非总是打开
- 不打开视频监控时,尽可能节省流量

使用框架及技术:
- go-kit
- gin
- gorm
- redis
- grpc

### 当前进度

进入交付小批量验证阶段

已经完成上述的所有主要业务功能

### 存在问题

完成主要业务功能后,发现主要问题

- 网关设备在线模块,配置引导模块具有一定耦合度.如果服务升级过慢,则会导致网关集体离线,导致设备配置重新下发
- 当前架构可靠性不高,不支持多个服务同时消费网关消息,无法实现负载均衡或者热备.
- 网关远程升级目前使用命令下发方式,存在无法查看升级进度,错误反馈,及升级日志集中管理.
- 所有的Event没有进行日志,或者说没有考虑Event设计.
- 未进行Admin及运维人员权限分离
- 运维排错较为麻烦.体现在第三方调用我方API没有足够的日志或者链路追踪.
- 第三方调用我方API时,出现调用方页面BUG导致的死循环调用摄像头推流请求,最终引起远程查看监控不稳定(不停的断开,连接,断开)

## 改造

### 已完成改造

- 使用errgroup来进行并行的请求管理.
- 对网关侧所有的command执行请求,按照课上所讲的context上下文控制timeout,保证在一定时间后必定返回,规避掉卡死或者可能出现的无限go请求调用.
- 使用go-kit + Opentracing来进行第三方业务请求的链路追踪,并在Jager中进行查看,可以完整看到第三方调用接口的时间,到达数据库请求,及最终返回等每一层所消耗的时间
- 对第三方业务调用的API进行限流,使用课程中所讲到的滑动窗口方式来进行限制,并对超出限制的请求直接返回Error,并给出具体的提示.


### 需针对Case进行改造

#### 1.解耦合

将网关在线检测模块,网关配置管理模块分离成2个微服务,使用grpc进行服务间通信.
- 在解耦合之前,参考Google API Desgin Guide对错误码,API格式进行规范
- 工程目录架构参考课程中所讲,将所有proto文件集中管理

#### 2.第三方业务API服务调整

针对供给第三方的API接口部分,调整为使用BFF的方式来进行,同时对于Service进行抽象

加入日志收集,用于第三方调用日志存储.使用Prometheus将第三方调用的日志集中存储,并使用ELK进行

#### 3.加入Event和Task

加入Task设计,用于远程网关固件升级,远程单片机升级,并对整个过程在服务端进行日志记录,按照网关ID进行日志索引.

实现大致思路为:
- 生产及消费者模型,异步.
- 管理人员配置Task,选定执行任务对象,任务时间,任务文件.例如,选择6个网关设备,用于小规模固件测试升级,升级时间为晚上8点,升级Firmware为xxxx版本.
- 配置后,所有任务可使用Kafka做为消息队列,将这些任务通过Kafka推送到任务执行模块
- 任务执行模块接受任务后,开始任务具体的下发,记录等其他操作.
- 对于非立即执行的Task,可使用计划任务定时执行
- 由于服务器资源(带宽,cpu)有限,对于批量下发Task执行的对象数量大于某个阀值(如100)时,Task生产者将Task执行对象进行分割,一次只下发X个对象(X由服务器带宽和网关设备速度计算而来),Y分钟后再下发另外一批X个对象,循环直至推送完成.
- 所有步骤均可进行日志记录,用于history回放或分析

#### 4.网关数据分析

加入网关远程执行命令的结果搜集,用于服务器排障,准确定位问题(规避掉,如升级失败,命令执行失败)

服务器接受到网关特定channel发送来的数据(主要是命令执行整个会话的日志)后,将数据记录到InfluxDB中,并使用Grafana进行展示

同时,对于某些日志,则使用ELK进行记录,并分析


### 5.Event触发及pipeline执行

当传感器数据上报到服务器,某个值符合规则引擎设定的Rule时,调用Result执行API,该API则使用Pipeline方式实现,多个Function连接到一起,对该数据进行处理(序列化,反序列化,加密,推送到其他第三方,调用通知等),Pipeline执行完成后,将最终结果(是否成功,err信息)返回到调用方.
该功能用于当某个关键指标值,如温度过高,需要通过邮件,短信,消息等告警到相应的运维人员进行快速处理.

而对于中途需要发送通知的process,则可以使用Kafka将该消息推送到任务执行方.

# 毕业总结

## 目标

本学期的心得体会、或者学习方法、自我总结都可以

## 总结

本人目前主要从事嵌入式开发,或者准确点说是全栈开发狮.曾经做过网络路由器开发,从单片机开发,嵌入式程序/驱动/固件开发,到服务端的服务器程序涉及开发,Web界面,小程序等等,也是一个不专业的CURD boy.开发语言在这12年中,几乎主流的均有涉及(C++是真不会...)

由于主要是C语言开发,习惯了编译性语言,对于内存消耗,编译测试及集成部署有那么一丢丢的“强迫症”,在服务端编程语言的选择中,也曾经用过Java(Spring全家桶),Python(Flask,Django),后来发现Go才是一直寻找的理想语言,可以同时用于服务器和网关硬件设备上(....咳咳,最近有点迷上Rust了,想把网关上的Python和Go全部换成Rust,手动狗头).

之前用Beego写过一些小程序,公众号的Server,也试着使用Go+casbin+gin做过模仿Java那一套东西.但做完后,始终觉得没有达到自己想要的那个Level,依然是个业务Boy.

经过这次的Go学习,收获颇丰.

首先,确认了一些之前的思路正确性(工程化,染色,Interface的设计).同时将所学的部分内容应用到了生产中,例如errgroup,err的封装,规范化处理,opentracing链路追踪,等等.

通过对于微服务的学习,开始对现有项目中使用到的第三方的框架,以及自己开发的Server有了新的认识.开始可以看懂哪些设计是存在缺陷(如超时处理,降级处理),哪些地方可以再修改(如使用grpc进行微服务之间的交互,并规范,甚至可以用于协议规范..;使用BFF,DDD思想来封装),哪些地方可以优化(如日志,err的规范及打印)

go runtime的学习后,对于Go,routine,内存模型,内存逃逸等有了新的认识,这对于在嵌入式上(内存受限)使用Go bin有极大的帮助.

当然,有一些内容,在当前的生产中并未使用过,对此领悟的不是太多.

经过这几个月的学习,将所学应该到现有的生产项目,做了一定的必要优化(过早的优化是魔鬼··),参考Kratos v1完成了多个小型服务(工具)的开发.

后续,有必要根据Kratos V2的源码,再次复习一次所有课程,重新整理小结.知识多次咀嚼,会有不同层次的收获.

## 个人小结点

通过毛大的讲解,有以下的小结:
- 整理出适合自己的方法论
- 方法,思路应在行动之前
- 遇到或问题,找寻现有优异项目,详细查看其文档,理解其设计思路(方法),切不可直接搬用.总结自己的套路用,逐步应用于自己的项目开发中
- 多看文档,多思考内在
- 看完他人资料,写完项目,对所涉及的知识点进行总结,并可以扩展到其他语言.
- 涉及的语言等已足够宽,接下来是对某几个语言的精通,在某个Domain的持续深入的价值远大于不停的做业务,做项目.
- 不一定要进入互联网大厂,某个Domain的精通也非常不错.坚持自己(正确的)的道路
- 管理切不可太慈,否则是对自己,团队和老板的不负责任.

